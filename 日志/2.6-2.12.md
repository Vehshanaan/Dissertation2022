<!--
 * @Author: Runze Yuan 1959180242@qq.com
 * @Date: 2023-02-10 13:35:29
 * @LastEditors: error: Runze Yuan && 1959180242@qq.com & please set dead value or install git
 * @LastEditTime: 2023-02-16 12:00:26
 * @FilePath: \Dissertation2022\日志\2.6-2.12.md
 * @Description: 
 * 
 * Copyright (c) 2023 by ${git_name_email}, All Rights Reserved. 
-->
## 第一周 

### **发生的事情**

初次组会

### 待办事项

1. 读老师给的材料
2. 为下周三的组会做准备，他下周希望我们能已经接受了概念，懂自己要干什么了
3. 要学的事项：
   1. ROS（他推荐用python版本）
   2. 通讯协议，冲突仲裁之类的知识
   3. 他给了若干的材料，看那个吧
4. 他希望二月底我们能有一个初步的规划，有一个草拟的计划，知道自己的项目目标，以及大概的路线图

### 计划
1. 从他给的材料里挑着看，先建立基础的认知
2. 把环境配一配，要不要装虚拟机？
### 问题
1. 现有的TDMA主要是分享信道，但我觉得信道与现实物理世界中的资源分享还是有根本性的区别的。
2. 建构系统要有一些要求。这种多机协作蜂群一般有哪些一定要能有的功能？比如说我可以使某机永远高优先级，总等待时间要最短，之类的？
3. 我觉得直接用论文的框架就可以实现所谓的自组织资源共享：
>   1. 各机之间通信用vanilla的STDMA就可以解决，configure（组态）的问题应该靠这样也可以解决。
>   2. 但是要解决的是资源共享的问题，比如抢茅房之类的问题。也许在slot传输的信息中要加上自己要用的是哪个坑的问题。把这个也加到碰撞处理里。
>   3. 怎么应对大量机器同时开机的问题？
>   4. 我觉得其实这种问题是可以分两层来解决：
> > - 把这个事情分成两层： 通信层自组织和资源共享自组织。这两个的冲突发生在不同层面上。应该是这么回事
> > - 利用STDMA的框架把通讯组织起来之后，再用STDMA的框架分享资源。
4. 可能存在的死锁问题
5. 同步时间戳的问题。
6. 新机体在运行时直接加入组织的问题  
**上面的都是技术问题，下面的是规划问题**     
7. 里程碑不清晰。因为我不知道会有哪些潜在的问题。也就有点难以制作计划。
8. 一般来说，像我这样的项目怎么规划时间？我觉得我就是永远会在重复一件事，就是实现算法并仿真，然后改进算法再仿真，直到永远。
9. 总之，我对于下一步该怎么组织我的研究还是比较迷茫。要我说就是直接开始上述的循环直到出成果为止。

灵感：如果某物被宣布被占用，那直到有人宣布自己不再使用为止，都算被占用。

### 2.15 会议记录

先不说优先级之类的东西，现在应该担心的就是多人会同时用一件东西。这就是唯一的限制。实验室就是四机一个降落点
先关注单个资源的分享问题吧

寻找milestone。先实现这个，再实现那个。这个是你的活儿。

题目不是你项目的限制，我只是拿那个招人，但你写的可以随便是啥都行。先找你的题目吧，这是最重要的。

一边让ROS准备好，把教程弄好。另一方面就是STDMA搞搞清楚就行了。

我们都不是通信高手，所以通信这块很难提升。你就用STDMA干资源共享就行。蜂群你想走的深度只取决于你自己。但是蜂群更多关于涌现式智能。所以蜂群。。。嗯。。。蜂群算法引起了他的的注意。他在琢磨。

https://apps.dtic.mil/sti/pdfs/ADA462317.pdf
https://ieeexplore.ieee.org/abstract/document/1605401

蜂群PDF 5k次引用。他的900次就不得了了，一般来说100次就挺高了。

就好像让蜂群钻小眼儿这种活儿。STDMA的方法可能和蜂群不一样。不过你应该会对蜂群感兴趣，因为有时候确实会有资源分享。STDMA的蜂群表现确实可以是个有意思的话题。



### 流水账

**2.10** 
> 写这个文件和文件夹  
> 修outlook
> 放弃了，outlook折腾不好还浪费了我一天的时间，上网页版吧，去他妈的了

**2.11**
> 开始读材料
> 材料清单：
>> - 关于算法的维基百科：https://en.wikipedia.org/wiki/Self-organized_time-division_multiple_access
>> - ROS 官方文档网页：http://docs.ros.org/en/humble/index.html
>> - 两份ROS的教程PDF: Dissertation2022\学习材料\ros_handout1.pdf  Dissertation2022\学习材料\ros_pres1.pdf
>> - 一份未发表的论文: Dissertation2022\学习材料\T-ITS_Point Merge System_V6_aeagr.pdf
>> - 一份关于此算法的PDF Dissertation2022\学习材料\ais_tdma_access_schemes.pdf

> 我心目中的阅读顺序：  
> 先读概念解释，再读论文，最后学ROS去搞完全模拟 

> 先读：[维基百科](https://en.wikipedia.org/wiki/Self-organized_time-division_multiple_access)
> > 首先，STDMA 是基于时分复用的信道使用方式
> > 然后，它是基于TDMA（时分多址），在TDMA的基础上加了一个S（自组织），使其可以不用中心站进行时隙（slots）分配与同步。我看他说这个自组织是基于UTC的，但仍然没有讲清楚怎么去除的中心站
> > 此算法被AIS（automatic indentification system / 自动识别系统）使用
>
> 再读：[AIS TDMA的访问sccheme PDF](A:\OneDrive\MScRobotics\Dissertation2022\学习材料\ais_tdma_access_schemes.pdf)
> > SOTDMA
> > - 自组织时分多址
> > - 是自组织网络运行的主干技术
> > - 所有站点共享同一个时间参考（GPS）
> > - 数据传输包含slot的分配计划，被使用的slot别人不能复用
> > -  （我有疑问的特性:）当某一机从一个地区移动到另一个地区时，系统要重新自组织。这个我不懂，但是可能我也用不上
>
> > RATDMA
> > - 随机存取时分多址
> > - 网络初始化时候的第一个时隙有时候会用这个
> > - 所有站点共享一个时间参考（GPS）
> > - 子站随机选取slot图中的一个无人使用的slot。子站不会以任何形式宣布自己使用这个slot。
> > - 由于站之间不知道谁用了哪个slot，会导致严重的数据冲撞，所以不适合周期性传输。偶尔用用得了
> > - A类AIS站会用这个来进行“网络进入”，此种情况发生在初次开机时，且此前没有设备使用SOTDMA宣布自己的时隙分配
>
> > ITDMA
> > - 也是共享时间参考
> > - 同样在slot图中选取一个没人用的slot自己用，但是会通过ITDMA传输来广播自己对这一slot的使用权
> > - 使用场景：某站需要在周期性信息的报告间隙宣布一个暂时变化，来提前宣布一个非周期性的信息（通常是关于安全之类玩意儿的信息），或者是在网络进入阶段使用一下。
> > - 这玩意儿单独拿出来作为TDMA协议是不成立的，它是SOTDMA的组件之一
>
> > FATDMA
> > - 手动设置的TDMA，人为规划好所有设备使用的slot。
> > - 仍然是共享时间参考
> > - 站点在安设时就设定好要用的slot
> > - 设置好FATDMA的站会传输一个Data Link管理信息，此信息会给其他站点提供被FATDMA占用的slot的提示。这会阻止范围内的其他站使用这些有主的slot。所以使用FATDMA的站应当尽量少，以避免对系统的影响，降低对系统动态行为的干涉。
>
> > CSTDMA
> > - 可与SOTDMA协作，并保证优先级总是交给SOTDMA传输
> > - **不使用GPS时间**，slot timing是用范围内的SOTDMA设备的时间来获得的
> > - CSTDMA站观察信号背景噪声等级，背景等级用于检测收到的信号强度，用来测量每个TDMA slot的起始
> > - 当需要传输时，随机选一个TDMA slot, 并检查slot起始时的背景噪声强度，如果强度显然高于正常，就说明slot正在被使用，不能插嘴。反之就该说说。
> > - 这种先听再传/载波感应式的解决方案是在slot的基础上运作的，这种做法将CSTDMA的传输限制在单个TDMA slot中，多slot的分配不能用这种技巧
>
> >Modified SOTDMA (Pre announced TDMA)
> > - 一种简单的TDMA，仅用于发送设备，它是一种为信号发射信标而特别设计的应用。
> > - 虽然名字里有SOTDMA，但是其实和SOTDMA没啥关系。它是用于嗓门小并且范围小的设备的
> > - 使用GPS作为时间参考
> > - 站点随机选取一个slot，首次发射时要宣布自己接下来连续使用8分钟的目的。下一周期的开始，就开始一个新的slot
>
> 然后读：我觉得读那个论文吧
>
> > **Point merge system using decentralized control** —— Yuan Gao, Arthur Richards 我怀疑是他和他的办公室室友
> > 
> > **Section 1**  
> > 先说PM（Point Merge System）:
> > 见论文图1，此系统定义了一堆预设的弧，以及一个集合点（Merge Point）。在此框架下飞行的飞行器应该在合适的时机收到一个“direct-to”式的指引。老些飞机场是这么玩的，都柏林，巴黎，莫斯科，上海，墨西哥城都是，还有一大堆其他的。**当前的PM系统都是中心化的。**  
> > 现在已有的改进PM系统的努力可以分为两个方面：
> > > 1. 优化  
> > > 大家发现Mixed Integer Linear Programing (MILP) 是最受欢迎的，也有好多人比划了启发式算法（heuristic algotrithm），如PSO, Genetic Algorithm  
> > > 2. 建模和模拟  
> > > 基本上所有的此方面研究都专注于用迭代解来评估PM的性能，在这当中无形之中就简化了飞行器动力学，通讯，人为因素，和controller与飞行器互动的问题。  
> > 
> > 此研究的主要动力是：  
> > > 1. 没人发表过去中心化的PM研究。本文专注于建构一个去中心化的PM系统的可能性。去中心化系统一向是可以避免中心失效的大麻烦，而且一般更scalable。但是这就要求agents之间有更多的联系，尤其是在PM这种生命攸关的情境下。本文探讨了文中方法的利弊。
> > > 2. 很少有人用state/behaviour-based方法（如FSM，行为树）来为PM系统建模。在这里使用FSM的主要原因之一是，在离线或实时模拟中，可以很容易地正确获得PM系统中每架飞机（以及控制器）的瞬态。使用FSM的另一个重要原因是，由于FSM可以灵活地模拟多种状态和分层结构，因此可以很容易地用FSM添加不确定性和人为因素（甚至是全新的agent）。  
> >
> > 本文的顺序： 
> >
> > > 1. 此部分
> > > 2. PM和基于FSM的agent建模
> > > 3. agent-based PM系统和其中心控制器
> > > 4. 发信机制（为了建构去中心的PM系统）
> > > 5. 用动态场景比较各种系统的性能
> > > 6. 结论
> >
> > **Section 2** Point Merge 以及基于agent的建模的一些基础知识  
> > 2.1 PM System  
> > > 本文中，假设所有的飞机以匀速运动。出于飞行安全的考量，PM区域被划分为四个区域（如Fig 1.所述）。为了简化，本文中用弧半径的一半来定义internal area（到这个区域里飞机就算成功），也就是说，弧半径是飞行器间最小允许距离的两倍。  
> > > 实际设计中，leg（那些弧）的设计是有scalability的，PM系统允许这样做。这当中的权衡在于燃料效能和系统可承载量这两者之间。因此，本文中用了不同的几何设置。如，serial legs（弧）的长度$L_{leg}$就设为了36海里（nautical miles），内层leg与中心点的距离（也就是弧的半径）是21海里，而对于外层leg，此数字是23。为确保两弧之中的飞机都有同等的安全转向距离，本文中假设 $R_1=R_2$...还有一堆关于模拟的数值，就先不看了。  
> >
> > 2.2 FSM以及Agent建模
> > >简单讲了一下本文的仿真方式，没啥看头。
> > 
> > **Section 3** 带有中心控制的PM系统  
> > >系统中有三种Agent: `Main Agent`, `Aircraft Agent`, `Controller Agent`。 
> > 
> > >`Main Agent`是最上层的agent，他给任务场景建模，例如，负责环境，leg path，设置参数/变量，以及agent，等等。另两种agent应当嵌入`Main Agent`，藉此加入整个的模拟。Fig 2.展示了`Aircraft Agent`和`Controller Agent`的结构。
> > 
> > > `Aircraft Agent`是系统的关键。此agent模拟PM系统中飞行器的所有可能状态。本文中有四种状态。
> > > > 1. 飞去leg
> > > > 2. 沿leg飞
> > > > 3. 飞向merge点
> > > > 4. 内部区域（着陆区）
> > >
> > > 只要飞行器收到信息，就飞去merge point.  
> > > 只要飞到了leg末尾，就自己飞去merge point。 这是一种非常危险的操作，而且会产生loss-of-seperation问题。出现此种情况代表PM系统超出了其最大可承载量。因而飞行器飞抵leg末端的频率和losing seperation downstream这两个玩意儿用来作为评估系统性能的metrics。
> > >
> > > 如图所示，`Controller Agent`有两个指令四个状态。  
> > > Turning态会向下一飞行器发送一个turning指令。Hold态会在有安全问题的情况下产生一个hold指令。由于hold显然比turning优先级高（安全攸关），有第三个state：Supervision来控制整体。使`Conroller Agent`不论在何时，只要发生Hold指令，就进入Hold态。
> > > Turn和Hold两个态在转出的时候各有一个手调的响应时间。响应时间结束后才会进入Supervision态。  
> > > `Controller Agent`遵循先来先服务的原则，有一个函数监控所有等待的飞机，并决定谁是下一个降落的。此系统最重要的部分就是何时飞机如何转向merge point。  
> > >  **本文的后续会介绍一种去中心化控制，让PM系统在没有控制器的情况下决定turning顺序。主要是通过信息的发和收来实现去中心化控制。**
> >  
> > **Section 4** PM系统的去中心化控制
> > > 所有的飞行器要靠彼此之间的信息发收来自己决定降落顺序。这样，前文所述的`Controller Agent`就可以部分/完全从系统中移除了。具体依情况而定。   
> >
> > > 算法主要受STDMA的启发。这是一种通讯信道使用协议。STDMA使用时间帧和slots来做到一种分散式的slot使用权保留，这种保留是针对系统中的所有节点的。节点使用相同的帧/slot持续时间，但由于各种随机进入，开始/结束时间是不同的。  
> >
> > 4.1 STDMA的原则  
> > > STDMA是一种分散的媒介访问控制方法。所有加入的成员都共享同一个通道进行通信。时间被划分为帧，由几个时隙（slot）组成。在每个帧中，每个站/节点将随机选择几个空闲时段来传输他们的信息。  
> > 
> > > 其原则可被总结为：
> > > - 在加入频道后，进入*初始化*阶段。`agent`花完整的一帧来听信道，与此同时**什么也不发**。在此阶段，新加入的`agent`记录当前的slot分布。
> > > - 在随后的*网络进入*阶段，`agent`随机选取一个空闲slot来宣布其存在并为自己保留一个slot。
> > > - 然后在*第一帧*阶段，`agent`要进一步为自己保留其他slot。
> > > - 再进入*连续（continuous)* 阶段，这一阶段就和第一帧是一样的，在开始新的一帧前，所有的slot保留情况应当被发送。
> >
> > > 当此协议被用于通讯时，每个`agent`可以使用多个slot，但对于去中心化PM，在*连续*阶段中，每个`agent`在每帧中只能使用一个slot。  
> > 
> > > 由于STDMA协议会形成一个全体一致的slot分布图，也就自然产生了排序。每架飞机可以知道前一架是谁。也就能知道什么时候进入merge point。
> > 
> > > 在本节的后续，提出了三种STDMA的变体。第一个非常接近原版，第二个和第三个都为改进slot排序进行了某种努力。对于通讯来说，帧和slot都飞快，排序对性能没啥影响，但是对于PM，糟糕的排序会导致飞行过远，或者干脆导致loss of seperation. 所以还是该付出一点努力在排序上的。
> >
> > 4.2 三种去中心化控制的策略  
> > 在保留位置后，每架飞机每帧只发送一次信息。*初始化阶段*仍然是要听，并确认当前的划分。但是在随后的*网络进入阶段*，会对已有的分配提出一个可选选项。同一channel的飞机仍然是按slot顺序降落，但是slot保留方法可能会不同。  
> > 三个控制策略的名字是：三种控制方案的名称是：带有网络入口的任意保留（Arbitary Reservation），带有直接保留的连续序列（Direct Reservation），以及带有网络入口的连续序列（Network Entry Scheme）。对于任意保留而言，slot保留是随机的，但是对另外两个，是先来先服务的。见Fig 3.
> >  
> > **4.2.1 Aribitary Reservation**
> > > 图中的绿箭头代表某一飞行器初次试着加入序列。首先花一个完整的帧，来听。然后知道哪些slot被其他飞行器占用。然后在空闲的slot中随机选一个归自己。当听的帧结束的下一slot不自由的时候，飞行器就往后等到有空闲slot的时候，作为自己的network entry slot，宣布自己的存在和保留slot是谁。注意，network entry slot不一定就是此飞行器的保留slot，因为slot都是随机保存的，不是连续保存的。
> >  
> > > 通过这种方式，slot保留可以是灵活的。NE槽是在最接近的槽（在监听阶段之后）使用。这个方案比其他两个方案有更多的机会在要保留的slot前宣布存在，因为是任意保留。 
> > > 此种方案的缺点主要来自于序列的确定方式上。slot靠后的飞机会永远被插队。
> >
> > **4.2.2 Direct Reservation**
> > > 监听阶段过去之后，飞机发现后续的slot被占用，那就跟在它们后面，用紧随其后的槽位再宣布自己的存在，并占用这个位置。
> > > 一大显著的问题就是飞机从监听到宣布自己存在要过很久很久，其他飞机在这一时段完全不知道还有你这么一个玩意儿在干等着。
> >
> >  **4.2.3 Network Entry**  
> > > 和第二个方案的唯一区别就是飞机在监听阶段之后直接用下一个slot作为NE槽，宣布自己使用队伍最后的空闲槽。NE槽和自己保留的槽分开，所以不叫direct reservation.
> > > 问题: 如果监听槽后面没有空闲，那么就会将此方案降级成方案2（Direct Reservation）。
> >
> > 4.3 碰撞后的信息发送和slot重分配
> > > “碰撞”意指两家飞行器想要给自己保留同一个slot这回事。因为它们的监听帧完全重合了，谁也不知道谁在。在碰撞发生的情况下，我们假设飞行器仍然会收到所有发送出去的信息，即，存在某种底层系统，在slot持续时也会一直发送所有信息。我们进一步假设所有信息都有一个“加入时间”，即，飞行器刚开始监听的时间。因而，加入时间最低的飞机被认为获得了保留的slot。其他碰撞的飞机现在就更新了它们的知识，重新再来。
> > 
> > > 每次飞行器碰撞都应该广播一个“ReSlot”信息。当发生碰撞的飞行器收到这种信息，加入时间就要和本地的加入时间作比较。比较完成后，更新后的slot号要广播。Fig 5.展示了这一流程。
> >
> > > 总的来说，就是比较飞行器的加入时间，并重新排序。
> >
> > 4.4 FSM建模
>
2.12 
> 初步读完了老师给的论文，有了一点自己的想法。接下来要再产生一些问题。  
> 先来ACaD吧，给自己的下周留一点余地。

2.13
> 上了一天课

2.14
> 自己扩展了一些论文阅读  
> 我的任务涉不涉及路线规划这种具体的问题？  
> 如何判断系统会不会自锁？让所有人死锁？
> 我的模拟中，印度刚具有哪些最基础的特性，使得模拟有点道理，不至于和以后的工作不互通？  
> **[工作环境可视化为具有许多小矩形单元格的网格，这些单元格被视为机器人的单位步骤。机器人可以移动到任何相邻的单元格。被障碍物占据的单元格显示为黑色或 1，没有颜色的空闲单元格表示为 0。机器人必须通过空闲单元格才能到达目标。一个单元格可以被认为是中间单元格（八连通）或边界单元格（由网格边界限制的邻居）](https://onlinelibrary.wiley.com/doi/full/10.1002/eng2.12132)**  
> [WiFi用的载波侦听发信技术](https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_avoidance)，此处要注意，有一点不同，这好像是中心化的，有一个玩意儿给设备发CTS（允许你说话）标志？再看看。  
> [RTS/CTS协议](https://baike.baidu.com/item/RTS%2FCTS%E5%8D%8F%E8%AE%AE/8971433?fr=aladdin)
> 我初步猜测的RTSCTS协议是这样的：主机接收到从机的RTS（请求发送）后，广播一个CTS（我准备好要接受了），而且这个CTS带着从机标号。也就是只听那一个的，这样来避免冲撞。  
> 还有一个问题，就是局域的边界的问题。多远之后就可以当同一群体中的其他萝卜不存在呢？要解决scalability这一点绕不开吧。  
> 我觉得要做规划，我有以下问题：
> - 里程碑不清晰。因为我不知道会有哪些潜在的问题。也就有点难以制作计划。
> 
