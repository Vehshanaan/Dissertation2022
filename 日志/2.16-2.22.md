<!--
 * @Author: Runze Yuan 1959180242@qq.com
 * @Date: 2023-02-16 11:59:24
 * @LastEditors: Runze Yuan 1959180242@qq.com
 * @LastEditTime: 2023-02-22 10:25:25
 * @FilePath: \Dissertation2022\日志\2.16-2.22.md
 * @Description: 
 * 
 * Copyright (c) 2023 by ${git_name_email}, All Rights Reserved. 
-->
## 第二周

### 发生的事情

### 待办事项

### 计划

分两个方面：
- ROS：开始设环境
- 阅读：
  - 读他给的材料   
https://apps.dtic.mil/sti/pdfs/ADA462317.pdf  
https://ieeexplore.ieee.org/abstract/document/1605401 
  - 他之前没想到STDMA能有蜂群式的智能，他说蜂群也可以看看。
  
总之，先实现基于STDMA的简单资源共享（如四个无人机分享一个降落地点），再进一步提升它。
记住，题目现在还不确定，那个题目并不是你要写的论文的题目。

### 问题

ROS版本选择的问题，ROS1还是2？哪个版本？我用的ROS2 on Ubuntu 22.04

这条偏向于总结：我发现蜂群和我想得挺不一样的，非常数学，很多都是基于能量函数控制，而不是像我我想的那种靠若干条简单逻辑控制。

我学了ROS2的教程的基础部分，现在搞了一个收一个发，但是都只是复制粘贴，还没有学到原理。逐步深入

我打算先实现简单时分复用资源共享，
再看看用这个能不能实现我的设想；

如果将二维平面抽象成若干网格，每个网格都看作是一个资源，那么将资源共享算法应用于这上面，就能产生一个蜂群。

然后在这个设想的基础上，逐渐改进不现实的地方，就得到一种组织群集机器人的方法。

当前状态：还是在学ros，逐渐熟悉自己的工具。


下周问题：怎么有效地找参考？


### 会议记录

是不是最新版？哦，foxy五月份就要凋零了，humble还有五年，那就还行。

ros的正确读音：不要读成玫瑰，有点像日嗷丝，总之中间发的是凹的音。念成别的会让人有点迷惑，容易跟不上。

蜂群没有目的。如果你需要设一个目的，就得有一个能量函数之类的东西，导向更高级的行为。这有点像自动化的领域的问题。简单的规则限制就只能实现低级的行为。

你的这个点子还不错。这个网格的点子还可以。先实现一个资源的分享，再实现网格这种设想。你还是得想想数量的问题，三四个ros还可以，但是上三位数就有点不太行了。这块得思考一下。你会折磨的地方就是ros的数量上限问题。

你要是能画一个你面临的问题的草稿，分解成各个步骤，就更有利于你的展示。譬如说，四个无人机分享一个降落点，四个无人机分享三个降落点。。。逐步叠加。就更好。

BRL entry的问题：不用太焦虑，老师发了邮件问update，问induction的事。等吧！

3.31 9.5 是两条死线。研究proposal和论文提交的两个死线。

https://ros2-industrial-workshop.readthedocs.io/en/latest/_source/navigation/ROS2-Turtlebot.html

老ros不会永远能用，虽然能用。所以还是支持你们用ros2。不过有时候ros2还是不太灵。核心就是，永远记住，你的活不是为了在ros12之间做移植。

他那天去了一个公司，他们对模拟和建模真的很感兴趣，也许可以给你们介绍介绍。

### 流水账

**2.15**

开组会
开完组会感觉前一天在图书馆太坐牢了，给自己放了一天假
修onedrive
OneDrive.exe在    
C:\Program Files\Microsoft OneDrive  
https://answers.microsoft.com/en-us/msoffice/forum/all/my-onedrive-is-stuck-at-0kb-sync-speed/d7df1d2a-48bf-4190-8605-7a85ab795249


**2.16**
> 抓空读一下他给的材料。
> https://apps.dtic.mil/sti/pdfs/ADA462317.pdf  
> https://ieeexplore.ieee.org/abstract/document/1605401  
> 这两个链接是同一篇。
>
> **Flocking for multi-agent dynamic systems: algorithms and theory**
> Abstract
> > 提到了Reynolds的三条法则：这三条法则用于提取集群蜂群式智慧的基础运作规律。  
> 
> 走了，先看Reynolds的三条法则。  
> 
> **Flocks, Herds, and Schools: A Distributed Behavioral Model**
>
>  
>  本文最早是想弄一个生成鸟群动画的东西。
> 快进到戏肉：三条法则：
> > - 避免碰撞 Collision Avoidance： 避免与周围其他人的碰撞
> > - 速度匹配 Velocity Matching: 试着和其他人的速度保持一致
> > - 扎堆 Flock Centering: 试着和周围的人保持邻近。  
> 
>  这三条法则优先级从上往下逐渐递减。
>  速度匹配其实也是一种防碰撞。它算是一种动态的防碰撞。  
> 三种行为各自产生一个速度矢量，然后将三个矢量以某种策略混合，那就能得到具体的下一步运动方向。  
> 它使用的决策方法：  
>   新的加速请求被按优先级排序，取其幅值，加到累加器中，如果累加器中累计的总幅值超过*最大加速度*值，就换速度。
> 潜在的问题：
> - 在高速运动的避障中，要求快速反应，如果三种决策提出的避障加速矢量相互抵消，那就出大麻烦了。
>
> 群体中的动物受其近处的其他个体的影响更大，远处的更无所谓。
> 
> 看完了Reynolds的三条法则，回归前一篇论文：  
>
> Reynolds的三条法则也叫内聚，分离和对齐法则。（*cohesion, seperation, alignment*）
>
> 图论基础，有向图和无向图，adjacency矩阵$A$
> 无向图的矩阵$A$是对称的，即$A^T = A$.
> 

**2.17**

刷求职信息，上课。

**2.18**

看ROS教程

学习材料\ros_pres1.pdf

> ROS就是机器人操作系统（operating system），但不是真的操作系统
> 使用黑板结构。   
> 
> AR个人认为的好处：
> - 正逐步成为一种支持丰富的标准
> - 可视化非常方便
> - 让他能用别人的工作
> - 帮他保持整洁  
> 
> AR个人认为的坏处：  
> - 非linux不可
> - 老更新，支持包有时候跟不上
> - 通过callback进行的异步timing，有时候会引入延迟和timing问题
> - 学习曲线初期非常陡峭
>
> 要用的版本： “kinetic”。   
> &emsp;*最新版叫lunar。*  
> 区别主要在于build工具  
> &emsp;*我们会一直用python来避免一些问题，C++得费老鼻子劲了。*
>
> **练习1：**  
> 设置你的ROS工作空间。  
> &emsp;*这事只用干一次。*  
> 学着与`catkin`共存  
> &emsp;*ROS最爱用的包管理和build工具*   
> &emsp;*里头有老些魔法咒语和魔药了*
>
> Node Topic 和 Service的概念：  
> - `node`是一个讲ROS语言的程序  
> - `topic`是一个信道，在`node`之间传递信息。  
> &emsp;`node`可以向`topic`发布信息，也可以订阅某一`topic`。  
> - `service`是`node`之间的request/response界面。
> &emsp;`node`可以提供`service`，也可以呼叫`service`。
>
> `Topic` vs `Service`:
>  - `Topic`是异步的单向数据传输信道  
> &emsp;只要我想就能往上发东西。  
> &emsp;有点像信件，邮件
> - `Service`是同步的，双向数据传输信道  
> &emsp; 我call，你respond  
> &emsp; call和respond都包含数据  
> &emsp; 有点像电话  
> - 一般用`Topic`  
> &emsp; **Actions**：通过`topic`进行的non-blocking service。
>
> **练习2：乌龟驱动**
> - 启动一个roscore
> - 提示，按`ctrl+shift+T`在终端中打开新页面
> - 启动乌龟模拟器  
> &emsp; `rosrun turtlesim turtlesim_node`  
> &emsp; 其中，`turtlrsim_node` 这个程序位于包`turtlesim`中。
>
**装了Ubuntu 20.04在VMware中，装了Chrome和谷歌输入法，但还没想好要用ROS1还是2**

**2.19**

学了本周的ACaD

学了本周的AI的材料，但是还没写那个labsheet。

先接着看论文吧。把论文看完才放心。

**2.20**

问导员要到了应届毕业生群，以及工大的就业办公众号

先接着读论文吧
论文基本上是一个人工势场法，他把蜂群之间的张力量化为一个势能函数，然后用这个函数来进行蜂群行为

感觉这个和我的不沾边，先试试ROS2 Humble吧。

**2.21**

今天选择在wills坐牢

本周要办的事：
- 写简历
- 捣鼓ROS
- 学本周的SR和AI

先捣鼓ROS，昨天临上课装了ubuntu22.04。看看这回能不能装上ros humble

解决vscode里不能打中文的问题：snap下的是阉割版，官方deb才是正道

学humble了

[ROS的domain ID设置问题](https://blog.csdn.net/amuro_ray027/article/details/116267842)

&emsp; 我就随便设一个0吧。应该没啥问题。

> 笔记：在turtle实例中，按下箭头再松开，只会使乌龟运动一小会就停止，因为你不会希望机器人在与操作者断开链接后还是能瞎动。这体现了某种理念。
>

读了node和topic的概念。


`node`：黑板的用户，观察黑板`topic`信息并根据信息作出若干行动  
`topic`：黑板，上面有可供用户`node`订阅的若干板块  
`service`：类似板擦的一种工具，可以添加`node`，修改已有的东西啥的，需要有人喊`call`才会执行`response`。

`Action`

![](http://docs.ros.org/en/humble/_images/Action-SingleActionClient.gif)

`Action`分三部分：Goal, Feedback, Result
- Goal 和 Result是用service实现的
- Feedback是用topic
- turtlesim例子里的定向旋转就是service
  
- client发送请求，server实现请求的内容

- 总结
  - 允许执行长时间运行的任务，提供定期反馈且可取消


rqt_console: 系统日志记录器
- 日志信息的五个严重性等级
  - Fatal
    - 系统将终止自己以避免重大损害
  - Error
    - 不一定会导致系统损坏，但会阻止系统正常运行的问题
  - Warn
    - 深层次问题的意外活动或不理想的结果，但不会完全损害功能
  - Info
    - 指示事件和状态更新，用来给你看系统有没有正常在运作的
  - Debug
    - 详细说明系统的整个逐步执行过程
  
怎么一次性启动多个node:
 - 他展示了一个python启动文件，调用了那个python，然后一口气变出来了两个小海龟
 - [启动教程](http://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Launch-Main.html)


把这一阶段的ROS2官方文档看完了，但是我觉得是真不行，再看richards的教程吧

richards的教程问题在于过时了！catkin在ROS2里已经弃用了。我再研究一下

但是命令的基础结构没有改变，我先通读一遍再说。



**用rqt的plugin的message publisher 向topic快速发送信息，不用自己用xml格式往命令行里打东西，真正的有效工具。**

[自制一个包（package）](https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html)

我发现又绕回来了，先看官方教程建立概念吧，richard的我得在脑子里翻译一遍才能知道要干啥，因为是ros1的教程。

ros的工作空间就是一个有特定结构的目录，一般来说，都会包含一个`src`子目录，然后除了这个子目录以外啥也没有。就在这个子目录里，包含ROS的包的源代码。

colcon用源码进行它的工作。创建几个`src`的对等目录

**什么是他妈工作区overlay？**  
  
默认安装的ROS包都在opt/ros/。。。下属，这些文件只属于root。所以要有一个继承功能：允许你继承所有那些包，然后在它的基础上覆盖一些东西，构建自己的一套工作空间。

教程中用的是基础的ROS2安装作为底层，但是实际上不一定要用这个作为底层。

这样就能对上层进行修改，但是不影响底层。先`source`底层的那个bash，再`source`上层的bash，就能做到这一点。

做了最基础的自制工作空间自制最小收发者的[教程](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html#)，但仍然还啥都不明白。今天先到这里吧。