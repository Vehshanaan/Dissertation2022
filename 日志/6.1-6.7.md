<!--
 * @Author: Vehshanaan@wsl2Ubuntu2204 1959180242@qq.com
 * @Date: 2023-06-02 15:53:41
 * @LastEditors: Vehshanaan@wsl2Ubuntu2204 1959180242@qq.com
 * @LastEditTime: 2023-06-02 17:55:53
 * @FilePath: /Dissertation2022/日志/6.1-6.7.md
 * @Description: 
 * 
 * Copyright (c) 2023 by ${git_name_email}, All Rights Reserved. 
-->
## 第2周

### 发生的事情

学完了ros2的通信机制部分，开始琢磨STDMA的实现

### 待办事项

设计STDMA在ros2中的实现思路，尝试实现

### 计划

### 问题

### 会议记录

### 流水账


**6.1**

重走STDMA路

STDMA数据包必须包含：时长，偏移，发送方的地理位置

新加入网络的站点要依次经历以下四个阶段：

1. 初始化阶段
   站点监听，以获得当前的slot分配信息。
   slot可以有以下四种状态：
   1. 内部分配：此slot已经被分配给自己（就归自己了，所以叫内部分配）。只要这种slot的时长大于0，此种slot的状态就会被维持。
   2. 外部分配： 观察到某一slot已被分配。这种知识有两种来源：
      1. 观察到某一slot被人使用
      2. 某一slot中宣布另一slot归谁
      只要此种slot的时长大于0，它的状态就会被维持。
   3. 忙  
      两种情况下，一个slot会被认证为忙：
      1. 在前一帧的这个slot中发现了有一个包，但没能成功解码
      2. 前一帧中这个slot的时候，接收端的平均能量水平高于清晰信道评估（CCA）阈值。
      忙态持续到下一帧结束为止。
   4. 自由  
      要满足三个条件，才认为一个slot是自由的：
      1. 过去没有证据表明这个slot会在未来被谁使用
      2. 此slot中没有检测到前导信息（preamble）
      3. 此slot中的平均能量水平高于清晰信道评估（CCA）阈值
   听了一帧之后，应当对当前的slot分配信息有了很好的了解。  
   监测从不暂停，为了保持站点的信息最新。  
   更新的三条原则：
   1. 只有当新状态比旧状态优先级更高时，才能覆盖前一帧中观测到的状态
   2. 如果一个slot被标记为外部分配，则使用新旧时长值中的最大值
   3. 外部分配->自由态的转换：只有保留期限已过，或者此slot连续三次被检测到是free的。
2. 网络进入阶段
   此阶段在初始化阶段结束后直接开始。在广播自己的存在（广播网络进入数据包完毕）后结束。  
   广播这个包的时机（用哪个slot？）是基于RATDMA（随机接入时分多重访问）协议。如下：  
   1. 为潜在的传输选择一个区间（SI selected interval），让它覆盖接下来的i个传输slot
   2. 通过包含SI中的所有自由slot，创建一个可能的传输slot列表
   3. 在每个可能传输的slot开始时，随机决定是否要使用它。
   实际上RATDMA用的是某种P坚持（p-presistance）机制，来决定在哪个slot中进行传输。
   网络入口数据包时一次性的传输，其内容为其所宣布占用的slot距离此帧开始的偏移量
3. 第一帧阶段
   只要一个站宣布了其存在，就进入了第一帧阶段。此阶段的任务是宣布和保留额外的slot，来达到报告速率的要求。  
   假设一帧有N个slot，此站的目标是每帧传输r个数据包，那工作以以下顺序展开：
   1. 计算帧长度和每帧要传输的数据包的数目的比例NI
   2. 从一帧的第一NI个slot里随机选一个NSS
   3. 后面每个NI长度的slot里都这么选NSS
   4. 具体的规则：对于每个NI：
      1. 在NSS左右加上一丢丢
      2. 在加完一丢丢的这个区间里选出备选slots
      3. 随机选一个slot用来传输
   在宣布所选slot的分配时，会从预定义的最大最小时长限制之间随机抽一个，所以每个slot的时长是不一样的。
4. 连续阶段
   1. 在此期间，只要slot的时长过期，就要重新分配，分配规则与第一帧阶段相同
   2. 但是，如果没有可用的候选slot，那就允许站点坚持当前slot


我遇到了开机问题。如果信道是一片空白，那就没法开始。我先琢磨一下，再问老师。

搞了namespace和name的关系（问bing可以得到回答），初步验证了launch的功能，初步构想通信逻辑

**6.2**

实现了判断信道是否有节点在里面的功能

卡在碰撞处理这里，明天要试一试ros的多节点同时发送会导致什么结果

**6.3**

决定还是用一个节点来模拟信道。

保存一下这个（曾经）比较重要的函数：

    def is_network_inited(self, timeout):
        """
        检测stdma信道中是否有成员。超过时间限制还没听见人说话则认定为false

        Args:
            timeout : 超时时长（秒），超过此时长还是啥也没听见则返回False

        Returns:
            bool: 有没有成员
        """

        result = rclpy.spin_once(self, timeout_sec=timeout)

        return result